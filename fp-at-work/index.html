<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="James Earl Douglas@jearldouglas" />
  <title>Putting functional programming to work</title>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js.gz"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Putting functional programming to work</h1>
  <p class="author">
James Earl Douglas<br /><a href="https://twitter.com/jearldouglas">@jearldouglas</a>
  </p>
  <p class="date">June 26, 2014<br />SF Scala</p>
</div>
<div class="section slide level1" id="abstract">
<h1 id="abstract">Abstract</h1>
<ul>
<li>Functional programming* promises safety, composability, and reusability</li>
<li>Let's connect these ideas with real-world** code</li>
</ul>
<p><em>This is an adaptation of <a href="http://bit.ly/real-world-fp">Real-World Functional Programming <span style="white-space:nowrap">(bit.ly/real-world-fp)</span></a>.</em></p>
</div>
<div class="section slide level1" id="words-mean-stuff">
<h1 id="words-mean-stuff">Words mean stuff</h1>
<p><em>Functional programming*</em></p>
<p>* consider FP â‰ˆ referential transparency</p>
<p><em>Real-world**</em></p>
<p>** for readability, we'll use a simplified (but analogous) example</p>
</div>
<div class="section slide level1" id="problem-space">
<h1 id="problem-space">Problem space</h1>
<p>Consider a banking ATM. A user should be able to:</p>
<ul>
<li>Check their balance</li>
<li>Deposit funds</li>
<li>Withdraw funds (and charge a fee)</li>
</ul>
</div>
<div class="section slide level1" id="why-another-atm-example">
<h1 id="why-another-atm-example">Why another ATM example?</h1>
<p>Accurate handling of state is kind of important, because money.</p>
</div>
<div class="section slide level1" id="data-types">
<h1 id="data-types">Data types</h1>
<p>We'll track a bank account as a simple transaction register.</p>
<ul>
<li>The type of each individual contribution and deduction is <code>Float</code></li>
<li>The type of an account is <code>List[Float]</code></li>
</ul>
</div>
<div class="section slide level1" id="state-change-as-a-side-effect">
<h1 id="state-change-as-a-side-effect">State change as a side effect</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">var</span> account: List[Float] = ...

<span class="kw">def</span> <span class="fu">deposit</span>(x: Float): Float = {
  account = account :+ x
  account.<span class="fu">sum</span>
}</code></pre>
<h2 id="drawbacks">Drawbacks</h2>
<ul>
<li>Mutable: <code>account</code> reference can change any time</li>
<li>Imperative: evaluating <code>deposit</code> makes the transaction happen</li>
<li>Inconsistent: <code>account</code> reference is accessed multiple times</li>
</ul>
</div>
<div class="section slide level1" id="state-change-as-a-computational-effect">
<h1 id="state-change-as-a-computational-effect">State change as a computational effect</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">deposit</span>(x: Float): List[Float] =&gt; (Float, List[Float]) =
  { account =&gt; (account.<span class="fu">sum</span>, account :+ x) }</code></pre>
<h2 id="improvements">Improvements</h2>
<ul>
<li>Immutable: <code>account</code> reference can not change</li>
<li>Declarative: evaluating <code>deposit</code> does not run the transaction</li>
<li>Consistent: <code>account</code> accesses are certain to be identical</li>
</ul>
</div>
<div class="section slide level1" id="representing-a-state-action">
<h1 id="representing-a-state-action">Representing a state action</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> State[S,A](run: S =&gt; (A,S))</code></pre>
<p>A <code>State</code> wraps a function <code>run</code> which, given an <code>S</code>, performs some computation and produces both an <code>A</code> and a new <code>S</code>.</p>
</div>
<div class="section slide level1" id="composing-with-pure-functions">
<h1 id="composing-with-pure-functions">Composing with pure functions</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> State[S,A](run: S =&gt; (A,S)) {

  <span class="kw">def</span> map[B](f: A =&gt; B): State[S,B] =
    State { run andThen { <span class="kw">case</span> (a,s) =&gt; (<span class="fu">f</span>(a), s) } }

}</code></pre>
<p><code>map</code> builds a new state action that, once run, has its output run through <code>f</code>, converting it from an <code>A</code> to a <code>B</code>.</p>
</div>
<div class="section slide level1" id="composing-with-pure-functions-1">
<h1 id="composing-with-pure-functions-1">Composing with pure functions</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> Tx[A] = State[List[Float],A]

<span class="kw">val</span> balance: Tx[Float] =
  State { account =&gt; (account.<span class="fu">sum</span>, account) }

<span class="kw">val</span> report: Tx[String] =
  balance map { x: Float =&gt; <span class="st">&quot;Your balance is &quot;</span> + x }</code></pre>
</div>
<div class="section slide level1" id="composing-with-state-actions">
<h1 id="composing-with-state-actions">Composing with state actions</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> State[S,A](run: S =&gt; (A,S)) {

  <span class="kw">def</span> flatMap[B](f: A =&gt; State[S,B]): State[S,B] =
    State { run andThen { <span class="kw">case</span> (a,s) =&gt; <span class="fu">f</span>(a).<span class="fu">run</span>(s) } }

}</code></pre>
<p><code>flatMap</code> builds a new state action that, once run, uses the output to compute the result of another state action.</p>
</div>
<div class="section slide level1" id="composing-with-state-actions-1">
<h1 id="composing-with-state-actions-1">Composing with state actions</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">deduct</span>(x: Float): Tx[Float] =
  State { account =&gt;
    <span class="kw">if</span> (account.<span class="fu">sum</span> &gt;= x) (x, account :+ (-x))
    <span class="kw">else</span> (<span class="dv">0</span>, account)
  }

<span class="kw">def</span> <span class="fu">deductWithFee</span>(x: Float]: Tx[Float] =
  <span class="fu">deduct</span>(x) flatMap { y =&gt;
    State { account =&gt;
      <span class="kw">val</span> fee = <span class="dv">3</span>
      (y + fee, account :+ (-fee))
    }
  }</code></pre>
</div>
<div class="section slide level1" id="the-state-monad">
<h1 id="the-state-monad">The state monad</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> State[S,A](run: S =&gt; (A,S)) {

  <span class="kw">def</span> map[B](f: A =&gt; B): State[S,B] =
    State { run andThen { <span class="kw">case</span> (a,s) =&gt; (<span class="fu">f</span>(a), s) } }

  <span class="kw">def</span> flatMap[B](f: A =&gt; State[S,B]): State[S,B] =
    State { run andThen { <span class="kw">case</span> (a,s) =&gt; <span class="fu">f</span>(a).<span class="fu">run</span>(s) } }

}</code></pre>
</div>
<div class="section slide level1" id="the-claims">
<h1 id="the-claims">The claims</h1>
<ul>
<li>Safe</li>
<li>Composable</li>
<li>Reusable</li>
</ul>
</div>
<div class="section slide level1" id="safety">
<h1 id="safety">Safety</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">contribute</span>(x: Float): Tx[Unit] =
  State { account =&gt; ((), account :+ x) }</code></pre>
<ul>
<li>No mutable references (i.e. <code>var account = ...</code>)</li>
<li>No mutable data structures (e.g. <code>account.append(...)</code>)</li>
<li>State actions are necessarily atomic</li>
<li>State actions are optionally transactional*</li>
</ul>
<p><em>* Depending on the later implementation of an interpreter</em></p>
</div>
<div class="section slide level1" id="composability">
<h1 id="composability">Composability</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">deposit</span>(x: Float): Tx[(Float,Float)] = 
  <span class="kw">for</span> {
    _ &lt;- <span class="fu">contribute</span>(x) <span class="co">// Tx[Unit]</span>
    b &lt;- balance       <span class="co">// Tx[Float]</span>
  } <span class="kw">yield</span> (<span class="dv">0</span>,b)

<span class="kw">def</span> <span class="fu">withdraw</span>(x: Float): Tx[(Float,Float)] =
  <span class="kw">for</span> {
    w &lt;- <span class="fu">deduct</span>(x)     <span class="co">// Tx[Float]</span>
    b &lt;- balance       <span class="co">// Tx[Float]</span>
  } <span class="kw">yield</span> (w,b)</code></pre>
<ul>
<li>Big state actions can be constructed from little state actions</li>
<li>Composition induces no side effects</li>
<li>Composition triggers no state transitions</li>
</ul>
</div>
<div class="section slide level1" id="reusability">
<h1 id="reusability">Reusability</h1>
<pre class="sourceCode scala"><code class="sourceCode scala"> <span class="kw">def</span> <span class="fu">depositThenWithdraw</span>(d: Float, w: Float): Tx[(Float,Float)] =
  <span class="kw">for</span> {
    _ &lt;- <span class="fu">deposit</span>(d)  <span class="co">// Tx[(Float,Float)]</span>
    w &lt;- <span class="fu">withdraw</span>(w) <span class="co">// Tx[(Float,Float)]</span>
  } <span class="kw">yield</span> w</code></pre>
<ul>
<li>State actions can be composed in different ways to create different behavior</li>
</ul>
</div>
<div class="section slide level1" id="interpreter">
<h1 id="interpreter">Interpreter</h1>
<p>To make it go, we need a way to run a state action:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">var</span> account: List[Float] = Nil

<span class="kw">def</span> <span class="fu">run</span>(x: Tx[(Float,Float)]): ((Float,Float),List[Float]) = {
  <span class="kw">val</span> ((w,b),a) = x.<span class="fu">run</span>(account)
  account = a
  ((w,b),a)
}</code></pre>
<p>Uh oh, there's that pesky <code>var</code> again...</p>
</div>
<div class="section slide level1" id="problems">
<h1 id="problems">Problems</h1>
<ul>
<li>Synchronizing access to mutable references</li>
<li>Wrapping state actions in transactions</li>
</ul>
</div>
<div class="section slide level1" id="solutions">
<h1 id="solutions">Solutions</h1>
<p>We can't escape mutability, but we <em>can</em> push it to the outer edges of our program, and tailor the interpreter to the mechanism of state persistence.</p>
</div>
<div class="section slide level1" id="demo">
<h1 id="demo">Demo</h1>
<script src="//scalave.earldouglas.com/scalave.js">

  case class State[S,A](run: S => (A,S)) {
    def map[B](f: A => B): State[S,B] =
      State { run andThen { case (a,s) => (f(a), s) } }
    def flatMap[B](f: A => State[S,B]): State[S,B] =
      State { run andThen { case (a,s) => f(a).run(s) } }
  }

  object Tx {
    def apply[A](run: List[Float] => (A, List[Float])) = State(run)
  }

  val action =
    for {
      _ <- Tx { account => ((), account :+ 100F) }
      x  = 20F
      w <- Tx { account =>
             if (account.sum >= x) (x, account :+ (-x))
             else (0F, account)
           }
      b <- Tx { account => (account.sum, account) }
    } yield (w,b)

  action.run(Nil)

</script>


</div>
</body>
</html>
